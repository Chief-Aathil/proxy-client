@startuml
title Proxy System Request Flow with RequestID and Multiplexing

participant "Browser\n(Client)" as Browser
participant "ClientConnectionListener\n(Ship Proxy)" as ClientListener
participant "ClientRequestHandler\n(Ship Proxy)" as ClientHandler
queue "RequestQueue\n(Ship Proxy)" as ReqQueue
participant "QueueConsumer\n(Ship Proxy)" as QConsumer
participant "HttpExecutor\n(Ship Proxy)" as HttpExecClient
participant "HttpsExecutor\n(Ship Proxy)" as HttpsExecClient
box "Persistent TCP Tunnel" #LightBlue
    participant "ProxyClientCommunicator\n(Ship Proxy)" as ClientComm
    participant "ProxyServerCommunicator\n(Offshore Proxy)" as ServerComm
end box
participant "HttpProcessor\n(Offshore Proxy)" as HttpProcServer
participant "HttpsProcessor\n(Offshore Proxy)" as HttpsProcServer
participant "Target Web Server\n(Internet)" as TargetServer



== HTTP Request Flow ==
Browser -> ClientListener: 1. HTTP GET request (e.g., http://example.com)
ClientListener -> ClientHandler: 2. New connection, hand-off to new handler
ClientHandler -> ClientHandler: 3. Generate unique requestID (e.g., UUID-1)
ClientHandler -> ClientHandler: 4. Create ProxyRequestTask(requestBytes, requestID, CompletableFuture<Response>)
ClientHandler -> ReqQueue: 5. Add ProxyRequestTask to queue (producer)
ClientHandler -> ClientHandler: 6. Wait for CompletableFuture to complete (blocking for this handler)

QConsumer -> ReqQueue: 7. Take ProxyRequestTask (UUID-1) from queue (single consumer)
QConsumer -> HttpExecClient: 8. Invoke HttpExecutor with ProxyRequestTask(UUID-1)
HttpExecClient -> ClientComm: 9. Frame requestBytes into FramedMessage(TYPE=HTTP_REQUEST, ID=UUID-1, payload=requestBytes)
ClientComm -> ServerComm: 10. Send FramedMessage(UUID-1) over persistent TCP tunnel

ServerComm -> ServerComm: 11. Receive FramedMessage(UUID-1)
ServerComm -> HttpProcServer: 12. De-frame and hand-off to HttpProcessor(requestBytes, UUID-1)
HttpProcServer -> TargetServer: 13. Execute actual HTTP GET request
TargetServer --> HttpProcServer: 14. Return HTTP response
HttpProcServer -> ServerComm: 15. Frame responseBytes into FramedMessage(TYPE=HTTP_RESPONSE, ID=UUID-1, payload=responseBytes)
ServerComm -> ClientComm: 16. Send FramedMessage(UUID-1) over persistent TCP tunnel

ClientComm -> ClientComm: 17. Receive FramedMessage(UUID-1)
ClientComm -> ClientHandler: 18. De-frame, use requestID to find waiting CompletableFuture, complete it with responseBytes
ClientHandler -> Browser: 19. Write responseBytes to browser socket
ClientHandler -> ClientListener: 20. Close browser connection

== HTTPS Request Flow (CONNECT Method) ==
Browser -> ClientListener: 21. HTTPS CONNECT request (e.g., CONNECT google.com:443)
ClientListener -> ClientHandler: 22. New connection, hand-off to new handler
ClientHandler -> ClientHandler: 23. Generate unique requestID (e.g., UUID-2 for this tunnel)
ClientHandler -> ClientHandler: 24. Create ProxyRequestTask(connectRequestBytes, requestID, CompletableFuture<TunnelReadySignal>)
ClientHandler -> ReqQueue: 25. Add ProxyRequestTask to queue
ClientHandler -> ClientHandler: 26. Wait for TunnelReadySignal

QConsumer -> ReqQueue: 27. Take ProxyRequestTask (UUID-2) from queue
QConsumer -> HttpsExecClient: 28. Invoke HttpsExecutor with ProxyRequestTask(UUID-2)
HttpsExecClient -> ClientComm: 29. Frame CONNECT request into FramedMessage(TYPE=HTTPS_CONNECT, ID=UUID-2, payload=connectRequestBytes)
ClientComm -> ServerComm: 30. Send FramedMessage(UUID-2) over persistent TCP tunnel

ServerComm -> ServerComm: 31. Receive FramedMessage(UUID-2)
ServerComm -> HttpsProcServer: 32. De-frame and hand-off to HttpsProcessor(connectRequestBytes, UUID-2)
HttpsProcServer -> TargetServer: 33. Open raw TCP socket to google.com:443
TargetServer <-- HttpsProcServer: 34. (Internal socket setup)
HttpsProcServer -> ServerComm: 35. If successful, frame CONTROL_200_OK into FramedMessage(TYPE=CONTROL_200_OK, ID=UUID-2)
ServerComm -> ClientComm: 36. Send FramedMessage(UUID-2) over persistent TCP tunnel

ClientComm -> ClientComm: 37. Receive FramedMessage(UUID-2)
ClientComm -> HttpsExecClient: 38. De-frame, use requestID to find waiting CompletableFuture, complete it with TunnelReadySignal
HttpsExecClient --> ClientHandler: 39. TunnelReadySignal received by ClientHandler

alt Continuous Data Flow for UUID-2 Tunnel
    ClientHandler -> ClientComm: 40. **(LOOP)** Read raw encrypted bytes from Browser socket, Frame as FramedMessage(TYPE=HTTPS_DATA, ID=UUID-2, payload=bytes), Send
    ClientComm -> ServerComm: 41. Forward FramedMessage(UUID-2)
    ServerComm -> HttpsProcServer: 42. De-frame, Write raw bytes to TargetServer socket
    TargetServer --> HttpsProcServer: 43. **(LOOP)** Read raw encrypted bytes from TargetServer socket
    HttpsProcServer -> ServerComm: 44. Frame as FramedMessage(TYPE=HTTPS_DATA, ID=UUID-2, payload=bytes), Send
    ServerComm -> ClientComm: 45. Forward FramedMessage(UUID-2)
    ClientComm -> ClientHandler: 46. De-frame, Write raw bytes to Browser socket
end alt

Browser -> ClientHandler: 47. Browser closes connection (or inactivity timeout)
ClientHandler -> ClientHandler: 48. Detect browser socket closed
ClientHandler -> ClientComm: 49. Frame CONTROL_TUNNEL_CLOSE into FramedMessage(TYPE=CONTROL_TUNNEL_CLOSE, ID=UUID-2)
ClientComm -> ServerComm: 50. Send FramedMessage(UUID-2)
ServerComm -> HttpsProcServer: 51. De-frame, close TargetServer socket associated with UUID-2
ClientHandler -> ClientListener: 52. Close browser connection
@enduml